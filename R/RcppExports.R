# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Compute root squared mean error
#' @param Q1 Numeric.
#' @param Q2 Numeric.
#' @export
ComputeRmse <- function(Q1, Q2) {
    .Call('tess3r_ComputeRmse', PACKAGE = 'tess3r', Q1, Q2)
}

#' Compute average cross entropy
#' @param P Numeric.
#' @param Q Numeric.
#' @export
ComputeAveragedCrossEntropy <- function(P, Q) {
    .Call('tess3r_ComputeAveragedCrossEntropy', PACKAGE = 'tess3r', P, Q)
}

#' Binary coding of the genotype data matrix.
#' @param X Genotype matrix.
#' @param ploidy Numbet of chromosomes.
#' @param XBin Binary genotype matrix to fill.
#' @export
X2XBin <- function(X, ploidy, XBin) {
    invisible(.Call('tess3r_X2XBin', PACKAGE = 'tess3r', X, ploidy, XBin))
}

#' Convert the binary genotype matrix into genotype matrix.
#' @param ploidy Numbet of chromosomes.
#' @param XBin Binary genotype matrix.
#' @export
XBin2X <- function(XBin, ploidy) {
    .Call('tess3r_XBin2X', PACKAGE = 'tess3r', XBin, ploidy)
}

#' Compute graph sparse matrix with the heat kernel function.
#' @param coord Coordinate matrix.
#' @param sigma sigma numeric parameter.
ComputeHeatKernelWeightSparse <- function(coord, sigma) {
    .Call('tess3r_ComputeHeatKernelWeightSparse', PACKAGE = 'tess3r', coord, sigma)
}

#' Compute graph matrix with the heat kernel function.
#' @param coord Coordinate matrix.
#' @param sigma sigma numeric parameter.
#' @export
ComputeHeatKernelWeight <- function(coord, sigma) {
    .Call('tess3r_ComputeHeatKernelWeight', PACKAGE = 'tess3r', coord, sigma)
}

#' Compute graph matrix with an exponiential function.
#' @param coord Coordinate matrix.
#' @param sigma sigma numeric parameter.
#' @export
ComputeExponetialWeight <- function(coord, sigma) {
    .Call('tess3r_ComputeExponetialWeight', PACKAGE = 'tess3r', coord, sigma)
}

#' Sample genotype from the TESS3 generative model.
#' @param Q Ancestry coefficients matrix.
#' @param G Ancestral frequencies matrix.
#' @param coord Coordinate matrix.
#' @param ploidy Number of chromosome.
#' @param openMP_core_num If openMP this is the number of CPU used.
#' @export
SampleGenoFromGenerativeModelTESS3 <- function(Q, G, coord, ploidy, openMP_core_num = 1L) {
    .Call('tess3r_SampleGenoFromGenerativeModelTESS3', PACKAGE = 'tess3r', Q, G, coord, ploidy, openMP_core_num)
}

ComputeZHelper <- function(Q, n, L) {
    .Call('tess3r_ComputeZHelper', PACKAGE = 'tess3r', Q, n, L)
}

ComputeAdmixtedGeno <- function(geno, Z, n, L) {
    .Call('tess3r_ComputeAdmixtedGeno', PACKAGE = 'tess3r', geno, Z, n, L)
}

#' Compute Fst statistic
#' @param Q Ancestry coefficients matrix.
#' @param G Ancestral frequencies matrix.
#' @param D Number of chromosome + 1.
#' @export
ComputeFst <- function(Q, G, D) {
    .Call('tess3r_ComputeFst', PACKAGE = 'tess3r', Q, G, D)
}

InitOpenMP <- function(n) {
    invisible(.Call('tess3r_InitOpenMP', PACKAGE = 'tess3r', n))
}

ComputeMCPASolution <- function(X, K, Lapl, lambdaPrim, D, maxIteration, tolerance, Q, G, verbose) {
    invisible(.Call('tess3r_ComputeMCPASolution', PACKAGE = 'tess3r', X, K, Lapl, lambdaPrim, D, maxIteration, tolerance, Q, G, verbose))
}

ComputeMCPASolutionNoCopyX <- function(X, K, Lapl, lambdaPrim, D, maxIteration, tolerance, Q, G, verbose) {
    invisible(.Call('tess3r_ComputeMCPASolutionNoCopyX', PACKAGE = 'tess3r', X, K, Lapl, lambdaPrim, D, maxIteration, tolerance, Q, G, verbose))
}

